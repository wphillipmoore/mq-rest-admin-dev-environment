{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mq-rest-admin-dev-environment","text":"<p>Shared dockerized IBM MQ test environment for use across multiple repositories. Provides container lifecycle scripts, seed data, and a reusable GitHub Actions composite action for integration testing against a real MQ queue manager.</p>"},{"location":"#language-libraries","title":"Language libraries","text":"<p>This environment is used by the language-specific libraries in the mq-rest-admin project:</p> <ul> <li>mq-rest-admin-python</li> <li>mq-rest-admin-java</li> <li>mq-rest-admin-go</li> <li>mq-rest-admin-ruby</li> <li>mq-rest-admin-rust</li> </ul>"},{"location":"#what-this-repo-provides","title":"What this repo provides","text":"<ul> <li>Two queue managers (QM1 and QM2) running in Docker containers   with REST API access enabled</li> <li>Seed data covering all major MQ object types (queues, channels,   topics, namelists, processes, listeners)</li> <li>Cross-QM routing with bidirectional sender/receiver channel   pairs and gateway QM aliases for REST API command routing</li> <li>Lifecycle scripts for starting, seeding, verifying, resetting,   and stopping the environment</li> <li>CI composite action for use in GitHub Actions workflows</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started \u2014 prerequisites and quick   start</li> <li>Environment Contract \u2014   stable ports, credentials, and URLs</li> <li>CI Integration \u2014 composite action usage</li> <li>Lifecycle Scripts \u2014 script reference</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#develop-v110-2026-02-21","title":"[develop-v1.1.0] - 2026-02-21","text":""},{"location":"changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Add repository scaffolding and design decisions (#1)</li> <li>Migrate Docker config and lifecycle scripts from pymqrest (#4)</li> <li>Rename PYMQREST object prefix to DEV (#7)</li> <li>Add setup-mq composite action for CI consumption (#9)</li> <li>Parameterize docker-compose for per-project isolation (#12)</li> <li>Add weekly Trivy container image scan</li> <li>(ci) Add category prefixes to job names (#27)</li> <li>(validate) Adopt validate_local.sh dispatch architecture (#30)</li> <li>(ci) Add publish workflow for automated tagging and version bumps (#36)</li> </ul>"},{"location":"changelog/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Add full README and mark pymqrest migration complete</li> <li>Update self-references after repository rename (#18)</li> <li>Ban MEMORY.md usage in CLAUDE.md (#28)</li> <li>Ban heredocs in shell commands (#29)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Auto-add issues to GitHub Project (#16)</li> <li>Bootstrap sync-tooling and add commit/PR wrapper scripts (#20)</li> <li>Add CI workflow with docs-only detection and shellcheck (#22)</li> <li>Sync shared tooling to v1.0.5 (#24)</li> <li>Add .gitignore with pycache exclusion (#26)</li> <li>Sync managed scripts against standard-tooling v1.1.1 (#31)</li> <li>(ci) Remove push trigger from CI workflow (#33)</li> <li>Merge main into release/1.1.0</li> </ul>"},{"location":"ci-integration/","title":"CI Integration","text":"<p>This repository provides a composite action at <code>.github/actions/setup-mq/action.yml</code> for use in GitHub Actions workflows. The action starts the MQ containers, seeds them with test objects, and optionally verifies the environment.</p>"},{"location":"ci-integration/#usage","title":"Usage","text":"<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup MQ\n        id: mq\n        uses: wphillipmoore/mq-rest-admin-dev-environment/.github/actions/setup-mq@main\n        with:\n          verify: 'true'\n\n      # Use the outputs in subsequent steps\n      # ${{ steps.mq.outputs.qm1-rest-url }}\n      # ${{ steps.mq.outputs.qm2-rest-url }}\n</code></pre>"},{"location":"ci-integration/#inputs","title":"Inputs","text":"Input Required Default Description <code>project-name</code> No <code>mq-dev</code> COMPOSE_PROJECT_NAME for container isolation <code>qm1-rest-port</code> No <code>9443</code> Host port for QM1 REST API <code>qm2-rest-port</code> No <code>9444</code> Host port for QM2 REST API <code>verify</code> No <code>true</code> Run <code>mq_verify.sh</code> after seeding"},{"location":"ci-integration/#outputs","title":"Outputs","text":"Output Value <code>qm1-rest-url</code> <code>https://localhost:&lt;qm1-rest-port&gt;/ibmmq/rest/v2</code> <code>qm2-rest-url</code> <code>https://localhost:&lt;qm2-rest-port&gt;/ibmmq/rest/v2</code>"},{"location":"ci-integration/#what-the-action-does","title":"What the action does","text":"<ol> <li>Start containers \u2014 runs <code>scripts/mq_start.sh</code> with the    configured ports and project name</li> <li>Seed objects \u2014 runs <code>scripts/mq_seed.sh</code> to create all    <code>DEV.*</code> objects on both queue managers</li> <li>Verify (optional) \u2014 runs <code>scripts/mq_verify.sh</code> to confirm    all expected objects exist via the REST API</li> </ol>"},{"location":"ci-integration/#port-customization","title":"Port customization","text":"<p>Use the <code>qm1-rest-port</code> and <code>qm2-rest-port</code> inputs to avoid port conflicts when running multiple MQ environments in the same workflow:</p> <pre><code>- name: Setup MQ\n  id: mq\n  uses: wphillipmoore/mq-rest-admin-dev-environment/.github/actions/setup-mq@main\n  with:\n    project-name: 'my-tests'\n    qm1-rest-port: '19443'\n    qm2-rest-port: '19444'\n</code></pre>"},{"location":"development/","title":"Development","text":""},{"location":"development/#local-directory-structure","title":"Local directory structure","text":"<p>The language-specific libraries reference this repo as a sibling directory:</p> <pre><code>~/dev/\n  mq-rest-admin-dev-environment/     # this repo\n  mq-rest-admin-python/              # language library\n  mq-rest-admin-java/                # language library\n  mq-rest-admin-go/                  # language library\n</code></pre>"},{"location":"development/#starting-the-environment-from-a-language-library","title":"Starting the environment from a language library","text":"<p>From a language library repo, start the environment using relative paths:</p> <pre><code>../mq-rest-admin-dev-environment/scripts/mq_start.sh\n../mq-rest-admin-dev-environment/scripts/mq_seed.sh\n</code></pre>"},{"location":"development/#reset-workflow","title":"Reset workflow","text":"<p>To tear down the environment completely (including Docker volumes) and start fresh:</p> <pre><code>scripts/mq_reset.sh\n</code></pre> <p><code>mq_reset.sh</code> runs <code>docker compose down -v</code>, which removes all container data. Use <code>mq_stop.sh</code> instead if you want to preserve queue manager state across restarts.</p>"},{"location":"development/#adding-seed-objects","title":"Adding seed objects","text":"<p>Seed data is defined as MQSC commands in the <code>seed/</code> directory:</p> <ul> <li><code>seed/base-qm1.mqsc</code> \u2014 objects for QM1</li> <li><code>seed/base-qm2.mqsc</code> \u2014 objects for QM2</li> </ul> <p>To add a new object:</p> <ol> <li>Add the MQSC <code>DEFINE</code> command to the appropriate seed file</li> <li>Run <code>scripts/mq_reset.sh</code> to apply (or <code>mq_seed.sh</code> if using    <code>REPLACE</code>)</li> <li>Update <code>scripts/mq_verify.sh</code> if the new object should be    verified</li> <li>Update the seed data documentation</li> </ol>"},{"location":"development/#environment-variables","title":"Environment variables","text":"<p>The Docker Compose configuration supports port overrides via environment variables:</p> Variable Default Description <code>MQ_IMAGE</code> <code>icr.io/ibm-messaging/mq:latest</code> Container image <code>QM1_MQ_PORT</code> <code>1414</code> Host port for QM1 MQ listener <code>QM1_REST_PORT</code> <code>9443</code> Host port for QM1 REST API <code>QM2_MQ_PORT</code> <code>1415</code> Host port for QM2 MQ listener <code>QM2_REST_PORT</code> <code>9444</code> Host port for QM2 REST API <p>Set these before running <code>mq_start.sh</code> to use non-default ports:</p> <pre><code>QM1_REST_PORT=19443 QM2_REST_PORT=19444 scripts/mq_start.sh\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker: Docker Desktop or Docker Engine with Compose v2</li> <li>curl: For REST API health checks (pre-installed on macOS/Linux)</li> </ul>"},{"location":"getting-started/#quick-start","title":"Quick start","text":"<pre><code>scripts/mq_start.sh    # Start QM1 + QM2, wait for REST API readiness\nscripts/mq_seed.sh     # Run MQSC seed commands on both queue managers\nscripts/mq_verify.sh   # Verify seed objects exist via REST API\n</code></pre> <p>Once the environment is running, the REST APIs are available at:</p> Queue Manager REST API URL QM1 <code>https://localhost:9443/ibmmq/rest/v2</code> QM2 <code>https://localhost:9444/ibmmq/rest/v2</code> <p>Authenticate with <code>mqadmin</code> / <code>mqadmin</code> (full access) or <code>mqreader</code> / <code>mqreader</code> (read-only access).</p>"},{"location":"getting-started/#verify-the-environment","title":"Verify the environment","text":"<p>Run the verification script to confirm all seed objects were created successfully:</p> <pre><code>scripts/mq_verify.sh\n</code></pre> <p>This queries the REST API on both queue managers and checks that each expected object exists.</p>"},{"location":"getting-started/#stop-the-environment","title":"Stop the environment","text":"<pre><code>scripts/mq_stop.sh     # Stop and remove containers (preserves volumes)\n</code></pre> <p>To remove all container data and start fresh, use the reset workflow instead:</p> <pre><code>scripts/mq_reset.sh    # Stop, remove volumes, restart, and re-seed\n</code></pre> <p>See Lifecycle Scripts for full details on each script.</p>"},{"location":"lifecycle-scripts/","title":"Lifecycle Scripts","text":"<p>All lifecycle scripts are located in the <code>scripts/</code> directory. They manage the Docker container lifecycle for the MQ development environment.</p>"},{"location":"lifecycle-scripts/#script-reference","title":"Script reference","text":""},{"location":"lifecycle-scripts/#mq_startsh","title":"mq_start.sh","text":"<p>Starts the QM1 and QM2 containers and waits for both REST APIs to become ready.</p> <pre><code>scripts/mq_start.sh\n</code></pre> <p>The script:</p> <ol> <li>Runs <code>docker compose up -d</code> using <code>config/docker-compose.yml</code></li> <li>Waits for container health checks to pass</li> <li>Polls the REST API endpoints until they respond</li> </ol>"},{"location":"lifecycle-scripts/#mq_seedsh","title":"mq_seed.sh","text":"<p>Runs the MQSC seed scripts against both queue managers to create all development objects.</p> <pre><code>scripts/mq_seed.sh\n</code></pre> <p>The script:</p> <ol> <li>Copies <code>seed/base-qm1.mqsc</code> into the QM1 container</li> <li>Runs <code>runmqsc QM1</code> with the seed file</li> <li>Copies <code>seed/base-qm2.mqsc</code> into the QM2 container</li> <li>Runs <code>runmqsc QM2</code> with the seed file</li> </ol>"},{"location":"lifecycle-scripts/#mq_verifysh","title":"mq_verify.sh","text":"<p>Verifies that all expected seed objects exist by querying the REST API on both queue managers.</p> <pre><code>scripts/mq_verify.sh\n</code></pre> <p>The script checks each object type (queues, channels, topics, etc.) and reports success or failure for each.</p>"},{"location":"lifecycle-scripts/#mq_resetsh","title":"mq_reset.sh","text":"<p>Stops containers, removes Docker volumes, and restarts the environment cleanly.</p> <pre><code>scripts/mq_reset.sh\n</code></pre> <p>The script runs <code>docker compose down -v</code> to remove all container data, then calls <code>mq_start.sh</code> and <code>mq_seed.sh</code> to rebuild the environment from scratch.</p> <p>Warning</p> <p>This removes all queue manager state including any messages in queues. Use <code>mq_stop.sh</code> if you want to preserve state.</p>"},{"location":"lifecycle-scripts/#mq_stopsh","title":"mq_stop.sh","text":"<p>Stops and removes the containers but preserves the named Docker volumes.</p> <pre><code>scripts/mq_stop.sh\n</code></pre> <p>Queue manager state is retained in the <code>qm1data</code> and <code>qm2data</code> volumes and will be available on the next <code>mq_start.sh</code>.</p>"},{"location":"lifecycle-scripts/#typical-workflows","title":"Typical workflows","text":""},{"location":"lifecycle-scripts/#first-time-setup","title":"First-time setup","text":"<pre><code>scripts/mq_start.sh\nscripts/mq_seed.sh\nscripts/mq_verify.sh\n</code></pre>"},{"location":"lifecycle-scripts/#daily-restart","title":"Daily restart","text":"<pre><code>scripts/mq_start.sh    # Volumes preserved, no re-seed needed\n</code></pre>"},{"location":"lifecycle-scripts/#clean-reset","title":"Clean reset","text":"<pre><code>scripts/mq_reset.sh    # Removes volumes and re-seeds\n</code></pre>"},{"location":"architecture/cross-qm-routing/","title":"Cross-QM Routing","text":"<p>Both queue managers define transmission queues, remote queue definitions, and sender/receiver channel pairs for bidirectional message routing between QM1 and QM2.</p>"},{"location":"architecture/cross-qm-routing/#qm1-to-qm2","title":"QM1 to QM2","text":"Object Type Description DEV.QM2.XMITQ QLOCAL (XMITQ) Transmission queue to QM2 DEV.REMOTE.TO.QM2 QREMOTE Routes to DEV.QLOCAL on QM2 QM1.TO.QM2 SDR Sender channel to QM2 (<code>qm2:1414</code>) QM2.TO.QM1 RCVR Receiver channel from QM2"},{"location":"architecture/cross-qm-routing/#qm2-to-qm1","title":"QM2 to QM1","text":"Object Type Description DEV.QM1.XMITQ QLOCAL (XMITQ) Transmission queue to QM1 DEV.REMOTE.TO.QM1 QREMOTE Routes to DEV.QLOCAL on QM1 QM2.TO.QM1 SDR Sender channel to QM1 (<code>qm1:1414</code>) QM1.TO.QM2 RCVR Receiver channel from QM1"},{"location":"architecture/cross-qm-routing/#gateway-routing","title":"Gateway routing","text":"<p>Each queue manager defines a QM alias that enables the REST API on one queue manager to route MQSC commands to the other:</p> Queue Manager QM Alias Routes To Via QM1 QM2 QM2 DEV.QM2.XMITQ QM2 QM1 QM1 DEV.QM1.XMITQ <p>The QM alias is defined as a QREMOTE with an empty <code>RNAME</code>:</p> <pre><code>DEFINE QREMOTE(QM2) RNAME('') RQMNAME('QM2') XMITQ(DEV.QM2.XMITQ)\n</code></pre> <p>This allows the REST API's <code>runCommandJSON</code> endpoint on QM1 to execute commands on QM2 by specifying <code>QM2</code> as the target queue manager, and vice versa.</p>"},{"location":"architecture/cross-qm-routing/#channel-startup","title":"Channel startup","text":"<p>The sender channels are started automatically during seeding:</p> <pre><code>START CHANNEL(QM1.TO.QM2)   -- on QM1\nSTART CHANNEL(QM2.TO.QM1)   -- on QM2\n</code></pre> <p>Both channels connect using the Docker network hostnames (<code>qm1</code>, <code>qm2</code>) on port 1414.</p>"},{"location":"architecture/environment-contract/","title":"Environment Contract","text":"<p>The language-specific libraries depend on these stable details. Changes to any of these values are breaking changes and require coordination with all language libraries.</p>"},{"location":"architecture/environment-contract/#connection-details","title":"Connection details","text":"Property Value Queue manager 1 QM1 Queue manager 2 QM2 QM1 REST API <code>https://localhost:9443/ibmmq/rest/v2</code> QM2 REST API <code>https://localhost:9444/ibmmq/rest/v2</code> QM1 MQ listener <code>localhost:1414</code> QM2 MQ listener <code>localhost:1415</code> Admin user <code>mqadmin</code> / <code>mqadmin</code> Reader user <code>mqreader</code> / <code>mqreader</code> Docker image <code>icr.io/ibm-messaging/mq:latest</code> Docker network <code>mq-dev-net</code>"},{"location":"architecture/environment-contract/#seed-objects","title":"Seed objects","text":"<p>Both queue managers receive a shared set of <code>DEV.*</code> objects. QM1 has the full set covering all major MQ object types; QM2 has a minimal subset plus cross-QM routing counterparts.</p> <p>See Seed Data for the complete object listing.</p>"},{"location":"architecture/environment-contract/#ci-outputs","title":"CI outputs","text":"<p>The composite action exposes REST API base URLs as step outputs:</p> Output Value <code>qm1-rest-url</code> <code>https://localhost:9443/ibmmq/rest/v2</code> <code>qm2-rest-url</code> <code>https://localhost:9444/ibmmq/rest/v2</code> <p>See CI Integration for usage details.</p>"},{"location":"architecture/environment-contract/#language-libraries","title":"Language libraries","text":"<p>This environment is used by the language-specific libraries in the mq-rest-admin project:</p> <ul> <li>mq-rest-admin-python</li> <li>mq-rest-admin-java</li> <li>mq-rest-admin-go</li> <li>mq-rest-admin-ruby</li> <li>mq-rest-admin-rust</li> </ul>"},{"location":"configuration/docker-compose/","title":"Docker Compose","text":"<p>The Docker Compose configuration is located at <code>config/docker-compose.yml</code> and defines two IBM MQ container services with REST API access.</p>"},{"location":"configuration/docker-compose/#services","title":"Services","text":""},{"location":"configuration/docker-compose/#qm1","title":"QM1","text":"Property Value Image <code>icr.io/ibm-messaging/mq:latest</code> Hostname <code>qm1</code> MQ listener port <code>1414</code> (host: <code>1414</code>) REST API port <code>9443</code> (host: <code>9443</code>) Queue manager name <code>QM1</code>"},{"location":"configuration/docker-compose/#qm2","title":"QM2","text":"Property Value Image <code>icr.io/ibm-messaging/mq:latest</code> Hostname <code>qm2</code> MQ listener port <code>1414</code> (host: <code>1415</code>) REST API port <code>9443</code> (host: <code>9444</code>) Queue manager name <code>QM2</code>"},{"location":"configuration/docker-compose/#environment-variables","title":"Environment variables","text":"<p>Both services accept the same environment variables for port overrides:</p> Variable Default Description <code>MQ_IMAGE</code> <code>icr.io/ibm-messaging/mq:latest</code> Container image <code>QM1_MQ_PORT</code> <code>1414</code> Host port for QM1 MQ listener <code>QM1_REST_PORT</code> <code>9443</code> Host port for QM1 REST API <code>QM2_MQ_PORT</code> <code>1415</code> Host port for QM2 MQ listener <code>QM2_REST_PORT</code> <code>9444</code> Host port for QM2 REST API"},{"location":"configuration/docker-compose/#volumes","title":"Volumes","text":"<p>Each queue manager has a dedicated named volume for persistent data:</p> <ul> <li><code>qm1data</code> \u2014 mounted at <code>/var/mqm</code> in the QM1 container</li> <li><code>qm2data</code> \u2014 mounted at <code>/var/mqm</code> in the QM2 container</li> </ul> <p>The <code>mqwebuser.xml</code> configuration file is bind-mounted read-only into both containers at the Liberty web server configuration path.</p>"},{"location":"configuration/docker-compose/#health-checks","title":"Health checks","text":"<p>Both containers use the <code>dspmq</code> command as a health check:</p> <pre><code>healthcheck:\n  test: [\"CMD\", \"dspmq\", \"-m\", \"QM1\"]  # or QM2\n  interval: 10s\n  timeout: 5s\n  retries: 12\n</code></pre> <p>The <code>mq_start.sh</code> script waits for both containers to report healthy before returning.</p>"},{"location":"configuration/docker-compose/#network","title":"Network","text":"<p>Both services share the <code>mq-dev-net</code> Docker network, which allows the containers to communicate using their hostnames (<code>qm1</code>, <code>qm2</code>). This is required for the cross-QM sender/receiver channels.</p>"},{"location":"configuration/rest-api-users/","title":"REST API Users","text":"<p>REST API authentication is configured through the <code>mqwebuser.xml</code> file located at <code>config/mqwebuser.xml</code>. This file is bind-mounted into both containers at the Liberty web server configuration path.</p>"},{"location":"configuration/rest-api-users/#users","title":"Users","text":"User Password Role Access <code>mqadmin</code> <code>mqadmin</code> MQWebAdmin Full administrative access <code>mqreader</code> <code>mqreader</code> MQWebAdminRO Read-only access <p>Both users also have the <code>MQWebUser</code> role, which grants access to the MQ Console web UI.</p>"},{"location":"configuration/rest-api-users/#security-roles","title":"Security roles","text":"<p>The configuration defines roles for two Liberty applications:</p>"},{"location":"configuration/rest-api-users/#mq-console-comibmmqconsole","title":"MQ Console (<code>com.ibm.mq.console</code>)","text":"Role Users Description MQWebAdmin mqadmin Full admin access to the console MQWebAdminRO mqreader Read-only console access MQWebUser mqadmin, mqreader General console access"},{"location":"configuration/rest-api-users/#mq-rest-api-comibmmqrest","title":"MQ REST API (<code>com.ibm.mq.rest</code>)","text":"Role Users Description MQWebAdmin mqadmin Full admin access to REST endpoints MQWebAdminRO mqreader Read-only REST access MQWebUser mqadmin, mqreader General REST access"},{"location":"configuration/rest-api-users/#configuration-file","title":"Configuration file","text":"<p>The <code>mqwebuser.xml</code> uses Liberty's basic registry:</p> <pre><code>&lt;server&gt;\n  &lt;basicRegistry id=\"basic\" realm=\"defaultRealm\"&gt;\n    &lt;user name=\"mqadmin\" password=\"${env.MQ_ADMIN_PASSWORD}\" /&gt;\n    &lt;user name=\"mqreader\" password=\"${env.MQ_READER_PASSWORD}\" /&gt;\n  &lt;/basicRegistry&gt;\n  ...\n&lt;/server&gt;\n</code></pre> <p>Passwords are injected via environment variables set in the Docker Compose configuration (<code>MQ_ADMIN_PASSWORD</code> and <code>MQ_READER_PASSWORD</code>).</p>"},{"location":"configuration/seed-data/","title":"Seed Data","text":"<p>Seed data is defined as MQSC command files in the <code>seed/</code> directory. The <code>mq_seed.sh</code> script runs these files against the respective queue managers using <code>docker exec</code> and <code>runmqsc</code>.</p>"},{"location":"configuration/seed-data/#seed-files","title":"Seed files","text":"File Target <code>seed/base-qm1.mqsc</code> QM1 <code>seed/base-qm2.mqsc</code> QM2"},{"location":"configuration/seed-data/#qm1-objects","title":"QM1 objects","text":"<p>QM1 has the full set of development objects covering all major MQ object types:</p> Object Type Notes DEV.DEAD.LETTER QLOCAL Dead-letter queue (set on QMGR) DEV.QLOCAL QLOCAL General-purpose local queue DEV.XMITQ QLOCAL (XMITQ) Transmission queue DEV.QREMOTE QREMOTE Routes to DEV.TARGET on QM1 DEV.QALIAS QALIAS Alias for DEV.QLOCAL DEV.QMODEL QMODEL Temporary-dynamic model queue DEV.TOPIC TOPIC Topic string <code>dev/topic</code> DEV.NAMELIST NAMELIST Contains DEV.QLOCAL DEV.SVRCONN SVRCONN Server-connection channel DEV.SDR SDR Sender channel DEV.RCVR RCVR Receiver channel DEV.LSTR LISTENER TCP listener on port 1415 DEV.PROC PROCESS Process definition"},{"location":"configuration/seed-data/#qm2-objects","title":"QM2 objects","text":"<p>QM2 has a minimal subset of development objects:</p> Object Type Notes DEV.DEAD.LETTER QLOCAL Dead-letter queue (set on QMGR) DEV.QLOCAL QLOCAL General-purpose local queue DEV.SVRCONN SVRCONN Server-connection channel"},{"location":"configuration/seed-data/#cross-qm-objects","title":"Cross-QM objects","text":"<p>Both queue managers define additional objects for bidirectional message routing. See Cross-QM Routing for details.</p>"},{"location":"configuration/seed-data/#security-configuration","title":"Security configuration","text":"<p>Both queue managers disable connection authentication and channel authentication for containerized testing:</p> <pre><code>ALTER QMGR CONNAUTH(' ') CHLAUTH(DISABLED)\nREFRESH SECURITY TYPE(CONNAUTH)\n</code></pre> <p>Warning</p> <p>This configuration is for development and testing only. Never use these settings in production.</p>"}]}